package l2

import (
	"context"
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/trie"
	"github.com/holiman/uint256"
)

var (
	DepositEventABI     = "TransactionDeposited(address,address,uint256,uint256,bool,bytes)"
	DepositEventABIHash = crypto.Keccak256Hash([]byte(DepositEventABI))
	DepositContractAddr = common.HexToAddress("0xdeaddeaddeaddeaddeaddeaddeaddeaddead0001")
	L1InfoFuncSignature = "setL1BlockValues(uint256 _number, uint256 _timestamp, uint256 _basefee, bytes32 _hash)"
	L1InfoFuncBytes4    = crypto.Keccak256([]byte(L1InfoFuncSignature))[:4]
	L1InfoPredeployAddr = common.HexToAddress("0x4242424242424242424242424242424242424242")
)

// UnmarshalLogEvent decodes an EVM log entry emitted by the deposit contract into typed deposit data.
// parse log data for:
//     event TransactionDeposited(
//    	 address indexed from,
//    	 address indexed to,
//    	 uint256 value,
//    	 uint256 gasLimit,
//    	 bool isCreation,
//    	 data data
//     );
func UnmarshalLogEvent(blockNum uint64, txIndex uint64, ev *types.Log) (*types.DepositTx, error) {
	if len(ev.Topics) != 3 {
		return nil, fmt.Errorf("expected 3 event topics (event identity, indexed from, indexed to)")
	}
	if ev.Topics[0] != DepositEventABIHash {
		return nil, fmt.Errorf("invalid deposit event selector: %s, expected %s", ev.Topics[0], DepositEventABIHash)
	}
	if len(ev.Data) < 160 {
		return nil, fmt.Errorf("deposit event data too small (%d bytes): %x", len(ev.Data), ev.Data)
	}

	var dep types.DepositTx

	dep.BlockHeight = blockNum
	dep.TransactionIndex = txIndex

	// indexed 0
	dep.From = common.BytesToAddress(ev.Topics[1][12:])
	// indexed 1
	to := common.BytesToAddress(ev.Topics[2][12:])

	// unindexed
	// 0:32: value - big-endian
	dep.Value = new(big.Int).SetBytes(ev.Data[0:32])
	// 32:64: gas - big-endian
	gas := new(big.Int).SetBytes(ev.Data[32:64])
	if !gas.IsUint64() {
		return nil, fmt.Errorf("bad gas value: %x", ev.Data[32:64])
	}
	dep.Gas = gas.Uint64()
	// 64:96: isCreation - boolean, aligned with end.
	// If False == 0 then it will create a contract using L2 account nonce to determine the created address.
	if ev.Data[95] == 0 {
		dep.To = &to
	}
	// 96:128: data offset
	var dataOffset uint256.Int
	dataOffset.SetBytes(ev.Data[96:128])
	if dataOffset.Eq(uint256.NewInt(128)) {
		return nil, fmt.Errorf("incorrect data offset: %v", dataOffset[0])
	}

	// 128:160: data length
	var dataLen uint256.Int
	dataLen.SetBytes(ev.Data[128:160])
	if dataLen.Eq(uint256.NewInt(uint64(len(ev.Data) - 160))) {
		return nil, fmt.Errorf("inconsitent data length: %v", dataLen[0])
	}

	// 160:...: data contents
	dep.Data = ev.Data[160:]

	// TODO: mint field

	return &dep, nil
}

// CheckReceipts sanity checks that the receipts are consistent with the block data.
func CheckReceipts(block *types.Block, receipts []*types.Receipt) bool {
	hasher := trie.NewStackTrie(nil)
	computed := types.DeriveSha(types.Receipts(receipts), hasher)
	return block.ReceiptHash() == computed
}

const L1InfoDepositIndex uint64 = 0xFFFF_FFFF_FFFF_FFFF

func DeriveL1InfoDeposit(block *types.Block) *types.DepositTx {
	data := make([]byte, 4+8+8+32+32)
	offset := 0
	copy(data[offset:4], L1InfoFuncBytes4)
	offset += 4
	binary.BigEndian.PutUint64(data[offset:offset+8], block.NumberU64())
	offset += 8
	binary.BigEndian.PutUint64(data[offset:offset+8], block.Time())
	offset += 8
	block.BaseFee().FillBytes(data[offset : offset+32])
	offset += 32
	copy(data[offset:offset+32], block.Hash().Bytes())

	return &types.DepositTx{
		BlockHeight:      block.NumberU64(),
		TransactionIndex: L1InfoDepositIndex, // not from a log event, but generated by system
		From:             DepositContractAddr,
		To:               &L1InfoPredeployAddr,
		Mint:             nil,
		Value:            big.NewInt(0),
		Gas:              99_999_999,
		Data:             data,
	}
}

// DeriveL2Transactions transforms a L1 block and corresponding receipts into the transaction inputs for a full L2 block
func DeriveUserDeposits(block *types.Block, receipts []*types.Receipt) ([]*types.Transaction, error) {
	if !CheckReceipts(block, receipts) {
		return nil, fmt.Errorf("receipts are not consistent with the block's receipts root: %s", block.ReceiptHash())
	}

	height := block.NumberU64()

	var out []*types.Transaction

	for txIndex, rec := range receipts {
		if rec.Status != types.ReceiptStatusSuccessful {
			continue
		}
		for _, log := range rec.Logs {
			if log.Address == DepositContractAddr {
				dep, err := UnmarshalLogEvent(height, uint64(txIndex), log)
				if err != nil {
					return nil, fmt.Errorf("malformatted L1 deposit log: %v", err)
				}
				out = append(out, types.NewTx(dep))
			}
		}
	}
	return out, nil
}

func DerivePayloadAttributes(block *types.Block, receipts []*types.Receipt) (*PayloadAttributes, error) {
	l1Tx := types.NewTx(DeriveL1InfoDeposit(block))
	opaqueL1Tx, err := l1Tx.MarshalBinary()
	if err != nil {
		return nil, fmt.Errorf("failed to encode L1 info tx")
	}

	userDeposits, err := DeriveUserDeposits(block, receipts)
	if err != nil {
		return nil, fmt.Errorf("failed to derive user deposits: %v", err)
	}

	encodedTxs := make([]Data, 0, len(userDeposits)+1)
	encodedTxs = append(encodedTxs, opaqueL1Tx)

	for i, tx := range userDeposits {
		opaqueTx, err := tx.MarshalBinary()
		if err != nil {
			return nil, fmt.Errorf("failed to encode user tx %d", i)
		}
		encodedTxs = append(encodedTxs, opaqueTx)
	}

	return &PayloadAttributes{
		Timestamp:             Uint64Quantity(block.Time()),
		Random:                Bytes32(block.MixDigest()),
		SuggestedFeeRecipient: common.Address{}, // nobody gets tx fees for deposits
		Transactions:          encodedTxs,
	}, nil
}

type BlockPreparer interface {
	GetPayload(ctx context.Context, payloadId PayloadID) (*ExecutionPayload, error)
	ForkchoiceUpdated(ctx context.Context, state *ForkchoiceState, attr *PayloadAttributes) (ForkchoiceUpdatedResult, error)
}

// DeriveBlock uses the engine API to derive a full L2 block from the block inputs.
// The fcState does not affect the block production, but may inform the engine of finality and head changes to sync towards before block computation.
func DeriveBlock(ctx context.Context, engine BlockPreparer, fcState *ForkchoiceState, attributes *PayloadAttributes) (*ExecutionPayload, error) {
	fcResult, err := engine.ForkchoiceUpdated(ctx, fcState, attributes)
	if err != nil {
		return nil, fmt.Errorf("engine failed to process forkchoice update for block derivation: %v", err)
	} else if fcResult.Status != UpdateSuccess {
		return nil, fmt.Errorf("engine not in sync, failed to derive block, status: %s", fcResult.Status)
	}

	payload, err := engine.GetPayload(ctx, fcResult.PayloadID)
	if err != nil {
		return nil, fmt.Errorf("failed to get payload: %v", err)
	}
	return payload, nil
}
